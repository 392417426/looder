## js == 和 ===的区别
* == 数据类型不一样会隐式转换成相同的数据类型，再进行比较
* === 不会进行数据类型的隐式转换，还会比较数据类型

## 从输入地址到浏览器展示页面的过程中经历了什么
1、域名通过dns解析，找到ip，通过ip找到服务器，建立tcp连接
2、tcp连接成功后，浏览器发送http请求（加载资源前在浏览器缓存里面找资源，找不到资源或者缓存时间过期），服务器接收请求并返回页面资源
3、浏览器加载页面资源，并解析html文档，生成DOM树和cssom树，DOM树和cssom会合并成渲染树，然后布局和计算渲染树每个节点的位置和大小等等内容
4、把渲染树渲染到屏幕上

## tcp三次握手
客户端发送一个带有SYN标志的数据包给服务端，服务端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息，最后客户端再回传一个带ACK标志的数据包，代表握手结束，连接成功

## dns解析过程
1、查询浏览器dns缓存
2、查询系统dns缓存
3、查询运营商服务器
4、查询域名服务器

## 域名组成
例子（www.baidu.com） www是三级域名 baidu是二级域名 .com是顶级域名 .root是根域名 

## dns查询方式
递归查询、迭代查询

## cdn是什么？
它能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度

## js基本类型与引用类型的区别
基本类型的值是放在栈内存里面的，引用类型的地址是放在栈内存里面，它的值是放在堆内存里面的，因为它们保存在内存的方式不一样，所以变量的复制与函数传参有所差异。

## 栈内存和堆内存的区别
栈内存储存基础数据类型的值以及引用类型的地址、堆内存储存引用类型的值
栈内存数据类似栈数据结构遵循先进后出原则，堆内存是一颗二叉树来的

## 垃圾回收机制
* 主要是通过标记清除算法或者引用计数算法来定期找出不再使用的内存，然后把内存释放出来

* 标记清除算法
* 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0
* 然后从各个根对象开始遍历，把不是垃圾的节点改成1
* 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间
* 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收

* 引用计数算法
* 当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1
* 如果同一个值又被赋给另一个变量，那么引用数加 1
* 如果该变量的值被其他的值覆盖了，则引用次数减 1
* 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存

## xss攻击、攻击方式与防止xss攻击
* xss通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。
* 反射型（xss）：攻击者通过构建一个链接，把恶意脚本放在url上面，引导用户点击该链接，服务器接收到url的参数没做过滤然后直接返回给客服端，然后客服端执行了恶意脚本，进而危害数据安全
* 存储型（xss）：攻击者直接把恶意脚本保存在数据库里面，然后返回给客服端执行
* dom型（xss）:通过innerHtml、document.write等等方法在页面中插入代码
* 用户输入要进行过滤、转义html代码、尽量不要使用innenrhtml和document.write插入html代码

## encodeURI和encodeURIComponent的区别
* encodeURI方法不会对下列字符编码 ASCII字母 数字 ~!@#$&*()=:/,;?+'
* encodeURIComponent方法不会对下列字符编码 ASCII字母 数字 ~!*()'
* encodeURIComponent编码范围更大

## ajax请求过程
1、创建 XMLHttpRequest 对象
2、通过setRequestHeader改变头部信息
3、通过open方法来设置请求的类型、URL 以及是否异步请求
4、通过send方法发送请求
5、通过onreadystatechange来接收数据

## css 伪类与伪元素
* 伪类是用于选择DOM树以外的信息或者不能用简单选择器表示的信息
* 伪元素是指DOM树没有定义的虚拟元素

## 线性结构和非线性结构有哪些
* 线性结构:栈，队列，链表，线性表
* 非线性结构：二维数组，树、图